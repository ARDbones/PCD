\chapter{Eccezioni}

\section{Tipi di eccezioni}
In Java, errori ed eccezioni sono oggetti, appartenenti a classi derivate da \textbf{Throwable}, la superclasse base. Il tutto si può distinguere tra eccezioni controllate e non controllate; le prime sono casi anomali gestibili, le seconde sono errori logici irrimediabili.
In particolare:
\begin{itemize}
\item \textbf{Error} è la sottoclasse degli errori severi/fatali, di solito non gestibili; terminano il programma (es: out of memory).
\item \textbf{RuntimeException} racchiude gli errori logici che avvengono runtime, non gestibili perché sono effettivamente errori logici che richiedono una modifica del codice (es: divisione per zero, nullpointer, ecc).
\item le rimanenti \textbf{Exception} vanno gestite, o viene segnalato un errore a compile time.
\end{itemize}

\section{Sollevare un'eccezione, blocchi try-catch, il costrutto finally}
Un'eccezione viene lanciata dal throw creando un oggetto del tipo eccezione che si vuole lanciare. La throw blocca l'esecuzione e cerca il codice che deve gestirla.
Se un metodo non gestisce l'eccezione al suo interno, è necessario indicare nella segnatura i tipi di eccezione che lancia.
\begin{lstlisting}
void m() throws Exc {
    try {throw new Exc("errore");}
}
\end{lstlisting}
Il codice che può sollevare eccezioni va in un blocco try e l'eccezione viene gestita dal primo catch di tipo compatibile. L'ordine delle clausole è da sottoclasse a superclasse, altrimenti la superclasse prende tutte le eccezioni.
Al termine del blocco try-catch è possibile inserire il blocco finally, un blocco di codice che viene sempre eseguito, anche se nel try è stato eseguito un return. È un blocco di codice protetto, che esegue sempre, ed è utile per rilasciare le risorse.

\section{Clausole throws e overriding di metodi}
Quando si hanno metodi ridefiniti con throws nella segnatura, il metodo ridefinito deve lanciare eccezioni che sono sottotipo del precedente e non deve avere più eccezioni. 



