# Appello P3 25-02-2016

1. Una variabile dichiarata come **volatile**
     -  [ ] Può essere inserita in una cache di memoria in alcuni casi particolari
     -  [X] Condivide le medesime caratteristiche di visibilità dell'istruzione **synchronized**
     -  [X] Può essere utilizzata al posto di un **lock** nel caso in cui le modifiche di una variabile non dipendano dal valore della variabile stessa
     -  [ ] Può essere utilizzata al posto di un **lock** anche nel caso in cui le modifiche di una variabile dipendano dal valore della variabile stessa

2. Lo scopo principale della JVM è
     - [ ] Garantire l'efficienza dei programmi
     - [X] Garantire la portabilità dei programmi
     - [ ] Garantire la sicurezza dei programmi

4. Sia `public static void m()` un metodo statico di una classe **C** e sia **D** una sottoclasse di **C**. Quale affermazione è vera? 
      - [ ] **D** non può dichiarare un metodo `public static void m()`
      - [ ] **D** può definire un metodo *m()* solo se ha segnatura diversa da quella del metodo *m()* della classe **C**
      - [ ] L'invocazione `D.()` non compila
      - [X] **D** può definire un metodo `public static void m()`

5. Date le seguenti definizioni di classi, cosa stampa l'invocazione di `new D()`?

```java
class C {
  int x = foo();
  C() { System.out.println("C: x = " + x);}
  int foo() { System.out.println("C.m x = " + x); return 4}
}

class D extends C {
  int y = foo();
  D() { System.out.println("D: x = " + x + " y = " + y);}
  int foo() { System.out.println("D.m x = " + x + " y = " + y); return 4;}
}
```
  - [X] D.m x = 0 y = 0 
  - [X] C: x = 7
  - [X] D.x x = 7 y = 0
  - [X] D: x = 7 y = 7

6. Data la classe 

```java
  public class LazyInitRace {
    private ExpensiveObject instance = null;
    public ExpensiveObject getInstance() {
      if(instance == null) {
        instance = new ExpensiveObject();
        return instance;
      }
    }
  }
```

si riporti il nome esatto della *race condition* individuata al suo interno.

### **SOLUZIONE**

> DA INSERIRE RISPOSTA QUI

7. Usando le classi **A** e **B** definite come segue, scrivere l'istruzione che compila ma la cui esecuzione solleva un'eccezione del tipo `ClassCastException`

```java
class A {
  public void m1() { System.out.println("A m1");}
  public void m2() { System.out.println("A m2");}
}

class B extends A{
  public void m1() { System.out.println("B m1");}
}
```

### **SOLUZIONE**

> `B abs = (B) new A()`

8. Quale tra le seguenti strutture dati permette la ricerca veloce dei propri elementi e li mantiene ordinati tra loro?

    - [ ] Arraylist
    - [ ] HashSet
    - [ ] LinkedList
    - [X] TreeSet
    - [ ] HashMap

9. Date le seguenti classi ed il tipo di eccezione SQLException, di tipo "checked":

```java
class A {
  public void methodA() throws IOException {}
}

class B extends A {
  public void methodA() throws IOException,SQLException {}
}
```
L'overriding del `methodA()` compila.

  - [ ] Vero
  - [X] Falso

11. Si completi il seguente codice nel miglior modo possibile tale che una sua esecuzione produca in un thread separato la stampa di **1** SEMPRE prima della stampa **2**.

```java
public static void main(String[] args) throws InterruptedException {
  // creazione ed esecuzione thread 
  System.out.println("2");
}
```
### **RISPOSTA**

```java
Thread T = new Thread(new Runnable {
  public void run() {
    System.out.println("1");
  }
});
T.start();
T.join();

```
12. Sia **C** una classe all'interno della quale è definita la classe interna statica **I**. Quale delle seguenti affermazioni è vera?

    - [ ] Non si possono creare oggetti di tipo **I**, ma si possono dichiarare riferimenti di tipo **I**.
    - [ ] Si possono creare oggetti di tipo **I** solo a partire da oggetti di tipo **C**
    - [X] Si possono creare oggetti di tipo **I** anche senza aver creato alcun oggetto di tipo **C**
    - [ ] Si possono dichiarare riferimenti di tipo **I** inizializzandoli con oggetti di tipo **C**

13. Si indichi come è necessario modificare la dichiarazione della seguente classe `Node` per permettere al seguente codice di compilare.

```java
public class Node<T> {
  private T data;
  public static void main(String[] args) {
    Node<Integer> node = new Node<>();
    for(Integer i:node) {
      System.out.println(i);
    }
  }
}
```
### **SOLUZIONE**

```java
public class Node<T> {
  private T data;
  public static void main(String[] args) {
    Node<Integer> node = new Node<>();
      // perchè non posso scorrere con un for una struttura che non è un array
      System.out.println(node);
  }
}
```

14. Descrivere il comportamento del seguente programma:
```java

```
